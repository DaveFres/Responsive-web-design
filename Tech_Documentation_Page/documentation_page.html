<!DOCTYPE html>
<html>
<head>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="stylesheet" href="documentation_page.css">
	<title>Documentation Page</title>
</head>
<body>

<header>
	<nav id="navbar" class="navbar">
		<header class="article_heading">JavaScript по БЭМ</header>
		<ul>

			<li>
				<a href="#JavaScript_BEM" class="nav-link">JavaScript по БЭМ</a>
			</li>
			<li>
				<a href="#Single_subject_area" class="nav-link">Единая предметная область</a>
			</li>
			<li>
				<a href="#Binding_a_JavaScript_block_to_HTML" class="nav-link">Привязка JavaScript-блоков к HTML</a>
			</li>
			<li>
				<a href="#Splitting_code_into_parts" class="nav-link">Разделение кода на части</a>
			</li>
			<li>
				<a href="#The_principle_of_encapsulation" class="nav-link">Принцип инкапсуляции</a>
			</li>
			<li>
				<a href="#Declarative_principle" class="nav-link">Принцип декларативности</a>
			</li>
			<li>
				<a href="#Principle_of_inheritance" class="nav-link">Принцип наследования</a>
			</li>
			<li>
				<a href="#Working_with_override_levels" class="nav-link">Работа с уровнями переопределения</a>
			</li>
			<li>
				<a href="#Working_with_blocks" class="nav-link">Работа с блоками</a>
			</li>
			<li>
				<a href="#The_interaction_of_blocks" class="nav-link">Взаимодействие блоков</a>
			</li>
			<li>
				<a href="#Block_interaction_with_elements" class="nav-link">Взаимодействие блока с элементами</a>
			</li>
			<li>
				<a href="#Working_with_modifiers" class="nav-link">Работа с модификаторами</a>
			</li>
			<li>
				<a href="#Reaction_to_the_change_of_modifiers" class="nav-link">Реакция на изменение модификаторов</a>
			</li>
			<li>
				<a href="#How_to_switch_To_JavaScript_by_BEM" class="nav-link">Как перейти на JavaScript по БЭМ</a>
			</li>

		</ul>

	</nav>
	
</header>


<main id="main-doc">

	<section class="main-section" id="JavaScript_BEM">
		<header class="article_heading">JavaScript по БЭМ</header>
		<article>
			<p>
			В БЭМ-методологии JavaScript — это одна из технологий реализации блока. Поэтому к JavaScript наравне с CSS применяются основные принципы методологии БЭМ:
			</p>

			<ul>
				<li>Единая предметная область</li>
				<li>Разделение кода на части</li>
				<li>Работа с уровнями переопределения и использование сборки</li>
			</ul>
			<p>
			Особенности реализации JavaScript по БЭМ-методологии рассматриваются в следующих разделах:
			</p>
			<ul>
				<li>
					Работа с блоками
					<ul>
						<li>Взаимодействие блоков</li>
						<li>Взаимодействие блока с элементами</li>
						<li>Работа с модификаторами</li>
						<li>Реакция на изменение модификаторов</li>
					</ul>
				</li>
				<li>Как перейти на JavaScript по БЭМ</li>
			</ul> 
		</article>
	</section>

	<section class="main-section" id="Single_subject_area">
		<header class="article_heading">Единая предметная область</header>
		
		<article>
			<p>Для работы с JavaScript наравне с другими технологиями используются термины блоков, элементов и модификаторов.</p>
			<p>В БЭМ к JavaScript применяется компонентный подход, который в отличие от Web Components не требует совместимости с браузерами. Независимым компонентом является блок. Аналогом Shadow Dom выступают элементы блока, которые реализуют принцип инкапсуляции. Модификаторы блоков и элементов отвечают за состояния. Установка/снятие модификатора изменяет поведение блока.</p>
			<p>Таким образом в БЭМ используется абстракция над DOM-деревом — БЭМ-дерево.</p>
			<p>Рассмотрим пример, в котором необходимо показать всплывающее окно (блок popup).</p>
			<p>Один из наиболее распространенных способов — добавить соответствующий класс и жестко прописать имя блока в коде.</p>

			<code>document.querySelector('.button').addEventListener('click', function() {
    document.querySelector('.popup').classList.toggle('popup_visible');
}, false);
			</code>

			<p>В БЭМ-проекте нет необходимости хардкодить имя блока. Поиск компонента выполняется по имени блока, так как имя всегда уникально. Сам компонент может выражаться классом, тегом, атрибутом и т.д. Отображение всплывающего окна также не зависит от класса: блок переводится в состояние visible с помощью добавления модификатора.</p>

			<code>block('button').click(function() { 
    block('popup').toggleMod('visible'); 
});
			</code>

			<p class="article_paragraph">
				<strong>Важно</strong> Для примеров, написанных по БЭМ-методологии, используется псевдокод. Реальные примеры реализации представлены в документации к i-bem.js.
			</p>
		</article>

	</section>

	<section class="main-section" id="Binding_a_JavaScript_block_to_HTML">
		
		<header class="article_heading">Привязка JavaScript-блоков к HTML</header>

		<article>
			<p>Первичным «каркасом» страницы является HTML-дерево документа. Блокам с JavaScript-реализацией могут соответствовать узлы в HTML с именем блока в атрибуте class. В этом случае говорится о том, что блоки имеют DOM-представление.</p>
			<p>
				Такой способ привязки JavaScript-компонентов к DOM-дереву имеет следующие преимущества:
				<ul>
					<li>естественная деградация интерфейса на клиентах с отключенным JavaScript;</li>
					<li>прогрессивный рендеринг — возможность начинать отрисовку элементов интерфейса до окончания загрузки всех данных страницы.</li>
				</ul>
			</p>		
			<p>В простейшем случае блок соответствует DOM-узлу один к одному. Однако DOM-узел и блок — это не всегда одно и то же. Можно разместить несколько блоков на одном DOM-узле (это называется микс), а также реализовать один блок на нескольких DOM-узлах.</p>
		</article>
	
	</section>

	<section class="main-section" id="Splitting_code_into_parts">

		<header class="article_heading">Разделение кода на части</header>

		<article>

			<p>В БЭМ-методологии поведение каждого блока описывается независимо. Независимость блоков в JavaScript позволяет повторно использовать блоки и реализуется за счет использования принципов:</p>

			<ul>
				<li>инкапсуляции</li>
				<li>декларативности</li>
				<li>наследования</li>
			</ul>

			<p>Логика работы каждого блока, его опциональных элементов и модификаторов описывается в отдельных файлах. JavaScript-файлы хранятся в соответствии с правилами организации файловой структуры БЭМ-проекта.</p>

			<p>Рассмотрим на примере логотипа (блок logo), реализованного в технологии CSS.</p>

			<p>Блок logo в файловой структуре проекта:</p>

			<code>logo/           # Директория блока logo
    logo.css    # Реализация блока logo в технологии CSS</code>

    		<p>Добавим блоку logo новую функциональность: нажатие на логотип будет вызывать какое-то действие.</p>

    		<p>JavaScript-реализация блока logo:</p>

    		<code>document.querySelector('.logo').addEventListener('click', doSomething, false);</code>

    		<p>Файл logo.js в файловой структуре блока logo:</p>

    		<code>logo/           # Директория блока logo
    logo.css    # Реализация блока logo в технологии CSS
    logo.js     # Реализация блока logo в технологии JavaScript</code>

    		<p>Реализация поведения блока, как и его внешнего вида, независима и отделена от реализации других блоков не только логически, но и физически — вынесена в отдельный файл.</p>

		</article>

	</section>

	<section class="main-section" id="The_principle_of_encapsulation">
		
		<header class="article_heading">Принцип инкапсуляции</header>
		
		<article>

			<p>В БЭМ внутренняя реализация блока скрыта. Блок предоставляет API для взаимодействия с другими блоками. Таким образом достигается независимость блока, возможность его повторного использования.</p>

			<p>Элементы всегда являются внутренней реализацией блока, поэтому обращение к ним возможно только через API самого блока.</p>

		</article>
	
	</section>

	<section class="main-section" id="Declarative_principle">

		<header class="article_heading">Принцип декларативности</header>

		<article>
			
			<p>Логика работы блока описывается декларативно: как набор действий и условий, при которых эти действия необходимо выполнять. Это позволяет разделять функциональность блока на отдельные части и использовать уровни переопределения.</p>

		</article>

	</section>

	<section class="main-section" id="Principle_of_inheritance">

		<header class="article_heading">Принцип наследования</header>

		<article>
			
			<p>Декларативное описание поведения блоков позволяет использовать методы базового блока внутри производного, наследовать их. Новый блок может получать все свойства и методы базового.</p>

			<p>Также можно создавать цепочки наследования — блок наследуется от другого, который, в свою очередь, наследуется от третьего и т.д.</p>

			<p class="article_paragraph">Примеры реализации доступны в документации к i-bem.js.</p>

		</article>

	</section>

	<section class="main-section" id="Working_with_override_levels">
		
		<header class="article_heading">Работа с уровнями переопределения</header>

		<article>
			
			<p>Декларативное описание работы блока обеспечивает возможность использовать уровни переопределения для JavaScript наравне с CSS:</p>

			<ul>
				<li>реализовывать новое поведение блока на другом уровне переопределения, сохраняя предыдущее, наследовать и дополнять его (делать super call);</li>

				<li>полностью перекрывать поведение блока (переопределять);</li>

				<li>добавлять блоки с новым поведением в проект.</li>

			</ul>

			<p>С помощью уровней переопределения можно создать универсальную JavaScript-библиотеку блоков, изменять ее на проектном уровне и включать в проект только необходимое поведение блоков.</p>

			<p class="article_paragraph">Подробнее о подключении библиотеки в проект.</p>

			<p>Рассмотрим пример формы отправки сообщения.</p>

			<code>block('button').onSetMod({
    focused: {
        true: this.onFocus,
        false: this.onBlur
    }
});</code>

			<p>Запись в БЭМ-терминах позволяет:</p>

			<ul>
				<li>
					Полностью перекрывать поведение блока на другом уровне переопределения.
					<code>block('button').onSetMod({
    focused: {
        true: this.someCustomOnFocused  // Полное изменение поведение блока
    }
});</code>
				</li>
				<li>
					Добавлять или частично изменять поведение блока на другом уровне переопределения.
					<code>block('button').onSetMod({
    focused: {
        true: function() {
            this.__base.apply(this, arguments); // Вызываем предыдущую реализацию
            this.someCustomOnFocused();
        }
    }
});</code>
				</li>
			</ul>

			<p class="article_paragraph">Для работы с JavaScript в БЭМ-терминах и использования уровней переопределения в БЭМ создан специализированный фреймворк i-bem.js.</p>

		</article>

	</section>

	<section class="main-section" id="Working_with_blocks">

		<header class="article_heading">Работа с блоками</header>

		<section class="main-section" id="The_interaction_of_blocks">

			<header class="article_heading_small">Взаимодействие блоков</header>

			<article>
				<p>БЭМ-методология предполагает работу с независимыми блоками. Однако на практике полная независимость блоков недостижима.</p>

				<p>Блоки могут взаимодействовать друг с другом с помощью:</p>

				<ul>
					<li>Подписки на события других экземпляров блоков.</li>
					<li>Подписки на изменения модификаторов.</li>
					<li>Непосредственного вызова методов других экземпляров блоков или статических методов класса другого блока.</li>
					<li>Любых паттернов взаимодействия. Например, канала событий: все коммуникации происходят благодаря сообщениям, которые компоненты публикуют и слушают с помощью посредника.</li>
				</ul>

				<p class="article_paragraph">Примеры реализации доступны в документации к i-bem.js.</p>

				<p>БЭМ-методология рекомендует выстраивать взаимодействие между блоками в иерархическом порядке в соответствии с их расположением в DOM-дереве. Вложенный блок не должен ничего знать о родительском блоке, так как это нарушает принцип независимости компонентов.</p>
			</article>
		</section>

		<section class="main-section" id="Block_interaction_with_elements">
			
			<header class="article_heading_small">Взаимодействие блока с элементами</header>
			
			<article>
				
				<p>
					Элемент — это внутренняя реализация блока. Для работы блока с его элементами принято реализовывать дополнительные хелперы блока. Обращение напрямую к элементу другого блока невозможно. Взаимодействие с элементом происходит только через API блока, которому принадлежит данный элемент.
				</p>

			</article>

		</section>

	</section>


	
	<section class="main-section" id="Working_with_modifiers">

		<header class="article_heading">Работа с модификаторами</header>

		<article>
			
			<p>Поведение блока описывается с помощью состояний. Модификаторы содержат информацию о состояниях блока. Перевод блока в другое состояние производится при помощи установки/снятия модификатора. Изменение модификатора создает событие, которое можно использовать для работы с блоком.</p>

			<p>Например, чтобы отметить чекбокс, блоку checkbox нужно установить модификатор checked в значение true.</p>

			<p>Для корректной работы JavaScript в БЭМ-проекте все манипуляции с модификаторами должны производиться при помощи методов-хелперов. Изменять значение модификаторов следует с помощью спец методов, а не менять напрямую CSS-класс на соответствующем DOM-узле.</p>

			<p class="article_paragraph">Примеры реализации доступны в документации к i-bem.js.</p>

		</article>


		<section class="main-section" id="Reaction_to_the_change_of_modifiers">
			
			<header class="article_heading_small">Реакция на изменение модификаторов</header>

			<article>
				
				<p>
					В БЭМ реакция на установку/снятие модификатора описывается декларативно: изменение состояния автоматически вызывает код, который задекларирован для этого состояния. Если появляется модификатор (добавляется новый класс к DOM-узлу), то вся функциональность, свойственная этому модификатору, также применяется. Если модификатор исчезает, функциональность отключается.
				</p>

				<p>
					Переход блока из одного состояния в другое часто сопровождается изменениями его внешнего вида. Так как добавление модификатора блоку изменяет его класс на DOM-узле, а стили написаны опираясь только на классы, изменение класса автоматически приводит к изменению внешнего вида блока.	
				</p>

				<p>
					Чтобы динамически изменять состояния блоков и элементов, используются специальные методы для установки и снятия модификаторов.

				</p>

				<p class="article_paragraph">
					Примеры реализации доступны в документации к i-bem.js.
				</p>

				<p>
					Рассмотрим форму отправки сообщения, в которой выполняется следующее условие: если введен неправильный email, кнопка отправки (блок button) становится недоступна (получает модификатор button_disabled).
				</p>

				<p>
					Один из способов решения этой задачи — жестко прописать все условия в коде и постоянно выполнять проверку. Такой подход неудобен, так как любое изменение потребует изменений в коде вручную.
				</p>

				<p>
					Другой способ — использовать методологию БЭМ и задекларировать поведение блока таким образом, чтобы получить возможность перекрывать каждый модификатор отдельно на новом уровне переопределения. В декларации можно указать, как блок или элемент должен отреагировать на изменение модификатора.

				</p>

				<code>block('button').onSetMod({
    focused: {
        true: this.onFocus,
        false: this.onBlur
    }
});</code>

				<p>Такой подход дает возможность:</p>

				<ul>
					<li>Определять каждому состоянию свой внешний вид, добавив стили модификатору.</li>
					<li>Изменять или полностью перекрывать поведение блока с помощью уровней переопределения.</li>
				</ul>

			</article>

		</section>

	</section>


	<section class="main-section" id="How_to_switch_To_JavaScript_by_BEM">

		<header class="article_heading">Как перейти на JavaScript по БЭМ</header>

		<article>
			
			<p>Чтобы реализовать принципы БЭМ в проекте, необходимо:</p>

			<ul>
				<li>работать в единых терминах блоков, элементов и модификаторов во всех технологиях;</li>
				<li>создавать независимые компоненты (блоки) на уровне JavaScript;</li>
				<li>описывать поведение блока как набор действий и условий их выполнения;</li>
				<li>обращаться к элементам блока только через API самого блока и не нарушать принцип инкапсуляции;</li>
				<li>изменять поведение блоков, элементов и модификаторов с помощью уровней переопределения по аналогии с CSS;</li>
				<li>разделять код на мелкие независимые части для удобства работы с отдельными блоками;</li>
				<li>повторно использовать блоки.</li>
			</ul>

			<p>
				Чтобы начать использовать JavaScript по БЭМ в рабочем проекте, можно начать применять принципы БЭМ-методологии без использования специализированного фреймворка. Пример проекта с JavaScript по БЭМ на jQuery описан в статье БЭМ — это не только про CSS.
			</p>

		</article>
	
	</section>

</main>

</body>
</html>